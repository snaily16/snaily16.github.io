<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-09-17T22:27:34+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">The Art of Concurrency</title><link href="http://localhost:4000/blog/2024/pthreads-concurrency/" rel="alternate" type="text/html" title="The Art of Concurrency" /><published>2024-08-30T00:00:00+05:30</published><updated>2024-08-30T00:00:00+05:30</updated><id>http://localhost:4000/blog/2024/pthreads-concurrency</id><content type="html" xml:base="http://localhost:4000/blog/2024/pthreads-concurrency/"><![CDATA[<p>Hey there, fellow coders!</p>

<p>Are you ready to unravel the mystery of threads? Not the kind you use to sew or weave, but the kind that makes your computer run multiple tasks at same time. Yeah, that kind! No yarns, threads, or needles required!
In this post, we’ll dive into the world of pthreads in C, where we’ll learn how to create, manage, and synchronize threads to achieve concurrency and improve system performance. We’ll cover the basics of pthreads, exploring the best practices to follow and common pitfalls to avoid. So, buckle up and get ready to thread your way through the world of computer science!</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/threading/Cooking_multitasking.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

    </div>
</div>
<p>Imagine you’re cooking dinner and have to prepare multiple dishes at once. Cooking one dish after the other would take a lot of time; instead, you prepare each dish simultaneously. You’re chopping vegetables while the rice is cooking, and then preparing rotis while the vegetables are sautéing. This is an example of concurrency from day-to-day life.</p>

<blockquote>
"Nothing is particularly hard if you divide it into small jobs." – Henry Ford
</blockquote>
<p>In concurrency, multiple tasks are executed simultaneously, improving the overall efficiency and productivity of the system. In today’s world of multi-core processors and increasingly complex software systems, concurrency has become a crucial aspect of programming. By harnessing the power of concurrency, developers can create faster, more efficient, and more scalable applications that take full advantage of modern hardware. However, concurrent programming can be a daunting task, especially for those new to the field.</p>

<p>Let’s dive into the world of concurrent programming. One of the most popular ways to achieve concurrency in C programming is by using POSIX threads, also known as pthreads.</p>

<h2 id="what-are-pthread">What are pthread?</h2>
<p>POSIX threads, also known as pthreads, developed by IEEE, as a part of POSIX (Portable Operating System Interface) standard, are a set of APIs that allow developers to create multiple threads of execution within a single process. 
POSIX threads were developed in 1990s to provide a standardized threading API, addressing lack of portability and efficiency in concurrent code. While there were existing threading APIs, they were not compatible, making it difficult to write portable code. Pthreads aimed to provide a standardized API for multiple platforms.</p>

<p>The <code class="language-plaintext highlighter-rouge">pthreads.h</code> header file is the primary interface for POSIX threads. It provides a set of functions, macros, and types that enable developers to create, manage, and synchronize threads.</p>

<h2 id="thread-operations">Thread Operations</h2>
<p>In a POSIX threads environment, thread operations typically include -</p>

<ol>
  <li>Thread Creation: creating new threads within a process</li>
  <li>Termination: terminating threads when they’re no longer needed</li>
  <li>Synchronization: coordinating access to shared resources between threads</li>
  <li>Scheduling: managing the execution of threads by the OS</li>
  <li>Data management: managing shared data between threads</li>
  <li>Process interaction: interacting with the parent process and other threads</li>
</ol>

<p>The Pthread API contains around 100 functions. These functions can be grouped in four major groups:</p>

<ul>
  <li>Thread management functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_create(), pthread_join()</code>)</li>
  <li>Synchronization functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_mutex_lock(), pthread_cond_wait())</code></li>
  <li>Thread attribute functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_attr_init(), pthread_attr_setdetachstate())</code></li>
  <li>Thread-specific data functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_setspecific(), pthread_getspecific())</code></li>
</ul>

<h2 id="thread-management">Thread Management</h2>
<p>When a program starts, it consists of a single, default thread, often referred to as the main thread. This thread is responsible for executing the main() function, which is the entry point of the program.
To get thread ID for the newly created thread, we use the <code class="language-plaintext highlighter-rouge">pthread_self</code> function.</p>

<h3 id="thread-creation-pthread_create">Thread Creation: pthread_create</h3>

<p>To create a new thread, we use the <code class="language-plaintext highlighter-rouge">pthread_create</code> function.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span> <span class="kr">thread</span><span class="p">,</span> 
                       <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span> <span class="n">attr</span><span class="p">,</span>
                       <span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> 
                       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></div>
<p>Let’s break down each argument:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">thread</code>: a pointer to a <code class="language-plaintext highlighter-rouge">pthread_t</code> variable that will store thread ID.</li>
  <li><code class="language-plaintext highlighter-rouge">attr</code>: a pointer to a <code class="language-plaintext highlighter-rouge">pthread_attr_t</code> structure that specifies thread attributes. (optional)</li>
  <li><code class="language-plaintext highlighter-rouge">start_routine</code>: a pointer to function that the new thread will execute.</li>
  <li><code class="language-plaintext highlighter-rouge">arg</code>: an argument to be passed to the <code class="language-plaintext highlighter-rouge">start_routine</code> function. It must be passed by reference as (void *) NULL</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">pthread_create</code> function returns zero on successful thread creation; otherwise, an error number shall be returned to indicate the error.</p>

<h4 id="best-practices-for-thread-creation">Best Practices for Thread Creation</h4>
<ol>
  <li>Use meaningful thread names to identify threads, this makes debugging easier.</li>
  <li>Use thread attributes to specify the thread’s scheduling policy, priority and other properties.</li>
  <li>Pass arguments carefully to avoid data corruption and ensure thread safety.</li>
</ol>

<h3 id="thread-termination-pthread_exit">Thread Termination: pthread_exit</h3>

<p>To terminate the calling thread, we use the <code class="language-plaintext highlighter-rouge">pthread_exit</code> function. It takes a single argument, <code class="language-plaintext highlighter-rouge">value_ptr</code>, which is a pointer to the exit status of the thread. This argument is optional, and if not provided, the thread exits with a default status.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value_ptr</span><span class="p">);</span>
</code></pre></div></div>
<p>This function allows thread to exit cleanly, realising any resources it may have allocated. While using the <code class="language-plaintext highlighter-rouge">pthread_exit</code>.</p>

<h4 id="best-practices-for-thread-termination">Best Practices for Thread Termination</h4>
<ol>
  <li>Use <code class="language-plaintext highlighter-rouge">pthread_exit</code> instead of <code class="language-plaintext highlighter-rouge">return</code> to terminate the thread. This ensures that the thread exists cleanly and releases resources it may have allocated.</li>
  <li>Pass on exit status to <code class="language-plaintext highlighter-rouge">pthread_exit</code> to provide information about the thread termination.</li>
  <li>Avoid calling <code class="language-plaintext highlighter-rouge">pthread_exit</code> from signal handler to prevent unexpected behaviour.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">pthread_join</code> to wait for the thread to terminate and ensure that resources are released.</li>
</ol>

<h3 id="waiting-for-thread-termination-pthread_join">Waiting for Thread Termination: pthread_join</h3>
<p>In addition to creating threads, it’s essential to manage their termination properly. One of the most critical aspects of thread termination is waiting for a thread to finish its execution. This is where <code class="language-plaintext highlighter-rouge">pthread_join</code> comes into play. When <code class="language-plaintext highlighter-rouge">pthread_join</code> is called the main program will block until the specified thread terminates.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">value_ptr</span><span class="p">);</span>
</code></pre></div></div>

<p>Let’s break down each argument:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">thread</code>: a pointer to a <code class="language-plaintext highlighter-rouge">pthread_t</code> variable that will store thread ID.</li>
  <li><code class="language-plaintext highlighter-rouge">value_ptr</code>: a pointer to a location where the thread’s return value will be stored.</li>
</ul>

<p>Once the thread finishes the execution, <code class="language-plaintext highlighter-rouge">pthread_join</code> will return the thread’s return value through the <code class="language-plaintext highlighter-rouge">value_ptr</code> argument. It allows you to synchornize the main program with the thread’s execution. This is particularly useful when the main program needs to wait for a thread to complete a task before proceeding.
If a thread encounters an error, <code class="language-plaintext highlighter-rouge">pthread_join</code> can help you catch and handle the error properly.</p>

<h4 id="best-practices-for-using-pthread_join">Best Practices for Using pthread_join</h4>
<ol>
  <li>Make it a habit to join threads to ensure proper resource cleanup and synchronization</li>
  <li>Always pair <code class="language-plaintext highlighter-rouge">pthread_join</code> with <code class="language-plaintext highlighter-rouge">pthread_create</code> to ensure that threads are properly created and terminated.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">pthread_join</code> to catch and handle errors that may occur during thread execution.</li>
</ol>

<p>Here is an example code that demonstrates the best practices:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"Hello, Thread!!!"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iret</span><span class="p">;</span>

    <span class="c1">// Create a thread</span>
    <span class="n">iret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_func</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error - pthread_create() return code: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">iret</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pthread_create for thread returns: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">iret</span><span class="p">);</span>
    
    <span class="c1">// Wait for the thread to finish</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Thread finished with return value %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">retval</span><span class="p">);</span>
    
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="c1">// Get the argument passed to the thread</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

    <span class="c1">// Get the thread ID</span>
    <span class="n">pthread_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Thread %ld started with message: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tid</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    
    <span class="c1">// Return a value to indicate success</span>
    <span class="n">pthread_exit</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To compile this program using GCC, we need to use the <code class="language-plaintext highlighter-rouge">-pthread</code> flag. This flag tells the compiler to link against the Pthread library. If you’re using a different C compiler, you’ll need to use a different (but equivalent) flag to link against the Pthread library. For example, with Clang compiler, we use the <code class="language-plaintext highlighter-rouge">-lpthread</code> flag.</p>

<p>Below is the example of how we can compile the above code (let’s name it thread_basic.c) in GCC:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -o thread_basic thread_basic.c -pthread
</code></pre></div></div>

<h2 id="thread-synchronization">Thread Synchronization</h2>

<p>When working with pthreads, synchronization is key to ensuring that your threads play nicely together. It is curcial to ensure that threads access shared resources safely and efficiently. Pthreads provide a range of synchronization functions that allow threads to coordinate their actions and avoid race conditions.</p>

<p>Types of Synchronization Functions:</p>
<ol>
  <li>Mutexes (Mutual Exclusion): Allow only one thread to access a shared resource at a time.</li>
  <li>Condition Variables: Allow threads to wait for a specific condition to occur before proceeding.</li>
  <li>Semaphores: Allow a limited number of threads to access a shared resource.</li>
  <li>Barriers: Allow multiple threads to wait until all threads have reached a specific point.</li>
</ol>

<p>To illustrate the concept of synchronization functions, let’s consider the earlier example of cooking dinner, but lets add multiple chefs.</p>

<h3 id="problem-statement-the-dinner-party-story">Problem Statement: The Dinner Party Story</h3>

<p>Imagine a busy kitchen where multiple chefs (threads) are working together to prepare a multi-course dinner for a large party. The kitchen has limited resources, such as ovens, stoves and utensils, which need to be shared safely among the chefs.</p>

<h3 id="example-1-critical-section-problem-with-mutexes">Example 1: Critical Section Problem with Mutexes</h3>

<p>Two chefs Alex and Luke, need to access the oven to bake different dishes. Without synchronization, both chefs might try to access the oven simultaneously, leading to conflicts and potentially ruining the dishes. To avoid this problem, the chefs use a mutex lock to synchronize the access to the oven.</p>

<p>A mutex (short for “mutual exclusion”) is a synchronization primitive that allows only one thread to access a shared resource at a time. In this example we’ll use the <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code> function to lock the mutex, ensuring that only one chef can access the oven at a time.</p>

<h4 id="declaration">Declaration:</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code> locks the mutex specified by varibale “mutex”. If the mutex is already locked, the calling thread will block until the mutex is unlocked by <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code>. 
The <code class="language-plaintext highlighter-rouge">pthread_mutex_trylock</code> is similar to <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code>, except that if the mutex object referenced by mutex is currently locked, instead of blocking the thread, it return immediately.</p>

<p>The <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code> and <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code> will returns 0 on success and error code on failure. The <code class="language-plaintext highlighter-rouge">pthread_mutex_trylock</code> will return 0 if a lock on the mutex object referenced by mutex is acquired, otherwise, and error code.</p>

<h4 id="the-code">The Code:</h4>
<p>Here is the code snippet that demonstrates how the chefs use a mutex lock to synchronize their actions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">oven_mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">Chef1</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="c1">// Bake dish 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef 1 is baking a cake... </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">Chef2</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="c1">// Bake dish 2</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef 2 is baking a pizza... </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="how-it-works">How it Works:</h4>
<ul>
  <li>The mutex <code class="language-plaintext highlighter-rouge">oven_mutex</code> is shared by Chef1 and Chef2 and is initialized using <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code>.</li>
  <li>They create their threads and start executing their respective thread functions. When Chef1 tries to access the oven, it locks the mutex using <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code>.</li>
  <li>Once the mutexis locked, Chef1 enters the critical section and bakes the cake.</li>
  <li>Meanwhile, if Chef2 also access the oven and see the mutex in locked state, it will block until the mutex is unlocked by Chef1.</li>
  <li>After baking the cake, Chef1 unlocks the mutex using <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code>.</li>
  <li>And similarly, chef2 locks the mutex, bakes the pizza and unlocks the mutex.</li>
</ul>

<p>By using a mutex lock, the chefs ensure that only one of them can access the oven at a time, preventing conflictst and ensuring that each dish is prepared perfectly.</p>

<h3 id="example-2-producer-consumer-problem-with-condition-variables">Example 2: Producer-Consumer Problem with Condition Variables</h3>

<p>Now, one of your chef, let’s say Claire, is responsible for preparing ingredients, while another chef, Phil, needs to use those ingredients to prepare a dish. 
Without synchronization, Phil (consumer) might try to use the ingredients before Claire (producer) has finished preparing them, reuslting in a dish that is incomplete or incorrect. For instance, Claire might be preparing a sauce, while Phil tries to use it before it’s ready, leading to a culinary disaster.</p>

<p>To avoid this problem, the chefs use a condition variable to synchronize their actions. A condition variable is a synchronization primitive that allows threads to wait until a specific condition is met. In this example we’ll use the <code class="language-plaintext highlighter-rouge">pthread_cond_wait</code> and <code class="language-plaintext highlighter-rouge">pthread_cond_signal</code> functions to implement the producer-consumer synchronization.</p>

<h4 id="declaration-1">Declaration:</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// wait on a condition</span>
<span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_timedwait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> 
                           <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">abstime</span><span class="p">);</span>

<span class="c1">// signal or broadcast a condition</span>
<span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>Wait on a condition:
    <ul>
      <li>Releases the mutex specified by <code class="language-plaintext highlighter-rouge">mutex</code> and waits until the condition varibale <code class="language-plaintext highlighter-rouge">cond</code> is signaled.</li>
      <li>They are called with mutex locked by the calling thread.</li>
      <li>Returns 0 on success, or an error code on failure</li>
      <li>The <code class="language-plaintext highlighter-rouge">pthread_cond_timedwait()</code> function is the same as <code class="language-plaintext highlighter-rouge">pthread_cond_wait()</code> except that an error is returned if the absolute time specified by abstime passes before the condition cond is signaled or broadcasted, or if the absolute time specified by abstime has already been passed at the time of the call.</li>
    </ul>
  </li>
  <li>Signal or brodcast a condition:
    <ul>
      <li>Signals the condition variable <code class="language-plaintext highlighter-rouge">cond</code>, waking up one or more threads that are waiting on it.</li>
      <li>Returns 0 on success, or an error code on failure</li>
      <li>The <code class="language-plaintext highlighter-rouge">pthread_cond_signal</code> wakes up at least one of the thread that are waiting on <code class="language-plaintext highlighter-rouge">cond</code>, whereas the <code class="language-plaintext highlighter-rouge">pthread_cond_broadcast</code> wakes up all the threads that are waiting.</li>
      <li>There is no effect for these functions if there are no threads currently blocked on <code class="language-plaintext highlighter-rouge">cond</code>.</li>
    </ul>
  </li>
</ol>

<h4 id="the-code-1">The Code:</h4>
<p>Here is the code snippet that demonstrates how the chefs use a condition variable to synchronize their actions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">sauce_mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">sauce_cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sauce_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Producer: Claire</span>
<span class="kt">void</span> <span class="nf">Chef_Producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="c1">// Prepare the sauce</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef Claire is preparing the sauce...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">sauce_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_cond</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Consumer: Phil</span>
<span class="kt">void</span> <span class="nf">Chef_Consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sauce_ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Use the sauce to prepare the dish</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef Phil is preparing the dish...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">sauce_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="how-it-works-1">How it Works:</h4>
<ul>
  <li>The mutex <code class="language-plaintext highlighter-rouge">sauce_mutex</code> and condition varibale <code class="language-plaintext highlighter-rouge">sauce_cond</code> are initialized using <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> and <code class="language-plaintext highlighter-rouge">PTHREAD_COND_INITIALIZER</code>, respectively.</li>
  <li>Claire (the producer) creates its thread and starts executing its thread function, she prepares the sauce and sets the <code class="language-plaintext highlighter-rouge">sauce_ready</code> flag to 1.</li>
  <li>Claire signals the condition variable using <code class="language-plaintext highlighter-rouge">pthread_cond_signal</code>, waking up Phil (the consumer).- Phil waits on the condition variable using <code class="language-plaintext highlighter-rouge">pthread_cond_wait</code> until the sauce is ready. Once its ready, Phil uses it to prepare the dish.</li>
  <li>Phil resets the <code class="language-plaintext highlighter-rouge">sauce_ready</code> flag to 0 to indicate that the sauce is no longer available.</li>
</ul>

<p>By using a condition variable, both Claire and Phil ensures that Phil wait until Claire has finished preparing the sauce, ensuring the dish is prepared correctly.</p>

<h3 id="example-3-reader-writer-problem-with-semaphores">Example 3: Reader-Writer Problem with Semaphores</h3>

<p>Our head chef, Gloria, has meticulously recorded all her grandmother’s recipes in her treasured recipe book, which only she is allowed to modify. Her team of chefs, including Phil, Claire, Alex and Luke, need to access to prepare different dishes.</p>

<p>Without proper synchronization, multiple chefs might attempt to access the recipe book simultaneously, leading to inconsistencies and errors. For instance, if one chef is reading a recipe while another chef is updating it, the first chef might obtain an outdated or incorrect recipe. To avoid this problem, the chefs utilize a semaphore to synchronize their access to the recipe book. A semaphore is a synchronization primitive that allows a limited number of threads to access a shared resource.</p>

<h4 id="declaration-2">Declaration</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// lock a semaphore</span>
<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="c1">// unlock a semaphore</span>
<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>Lock a semaphore:
    <ul>
      <li>Decrements the semaphore value.</li>
      <li>If the semaphore value is currently zero, <code class="language-plaintext highlighter-rouge">sem_wait</code> blocks the calling thread until the semaphore value becomes positive. When semaphore value is positive, it decrements the value and allows the thread to proceed.</li>
      <li>Unlike <code class="language-plaintext highlighter-rouge">sem_wait</code>, <code class="language-plaintext highlighter-rouge">sem_trywait</code> does not block the calling thread if the semaphore value is zero. Instead, it returns an error code.</li>
      <li>Returns 0 on success, or an error code on failure.</li>
    </ul>
  </li>
  <li>Unlock a semaphore:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">sem_post</code> call, increments the semaphore value and wakes up one or more threads that are waiting on it.</li>
      <li>Returns 0 on success, or an error code on failure.</li>
    </ul>
  </li>
</ol>

<h4 id="the-code-2">The Code:</h4>

<p>Here’s an example code snipped that demonstrates how the chefs use a semaphore to synchronize their access to the recipe book:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">sem_t</span> <span class="n">recipe_book_semaphore</span><span class="p">;</span>
<span class="cp">#define READERS 5
</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">ChefReader</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="c1">// Read the recipe book</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef %ld is reading recipe book...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">HeadChef</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="c1">// Wait for all readers to finish</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">READERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="c1">// Update the recipe book</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Head Chef is updating recipe book...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">READERS</span><span class="p">);</span> <span class="c1">// Allow up to n readers to access simultaneously</span>
  <span class="c1">// Create threads here...</span>
  <span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="how-it-works-2">How it Works:</h4>
<ul>
  <li>The semaphore <code class="language-plaintext highlighter-rouge">recipe_book_semaphore</code> is initialized uisng the <code class="language-plaintext highlighter-rouge">sem_t</code> type. This semaphore is used to synchronize access to the recipe book.</li>
  <li>When a ChefReader thread arrives, it waits for the semaphore to be available using sem_wait. If the semaphore is available, the thread decrements its value and continues execution. Since multiple ChefReader threads can decrement the semaphore value simultaneously, multiple readers can access the recipe book at the same time.</li>
  <li>When a HeadChef thread arrives, it also waits for the semaphore to be available using sem_wait. However, since the semaphore value is decremented by the ChefReader threads, the HeadChef thread will block until all ChefReader threads have finished reading the recipe book and released the semaphore. This ensures that the HeadChef thread has exclusive access to the recipe book when updating it.</li>
  <li>When a ChefReader thread finishes reading the recipe book, it releases the semaphore using sem_post, incrementing its value. This allows other ChefReader threads to access the recipe book.</li>
  <li>When the HeadChef thread finishes updating the recipe book, it releases the semaphore using sem_post, incrementing its value. This allows other threads to access the recipe book.</li>
</ul>

<p>By using a semaphore to synchronize access to the recipe book, the code ensures that multiple ChefReader threads can read the recipe book simultaneously, while the HeadChef thread has exclusive access to the recipe book when updating it.</p>]]></content><author><name></name></author><category term="code-for-fun" /><category term="c" /><category term="code" /><category term="os" /><summary type="html"><![CDATA[Unlock the power of concurrent programming in C, with practical examples using pthreads library]]></summary></entry><entry><title type="html">Beyond 3.14</title><link href="http://localhost:4000/blog/2023/calcuate-pi-for-fun/" rel="alternate" type="text/html" title="Beyond 3.14" /><published>2023-08-06T00:00:00+05:30</published><updated>2023-08-06T00:00:00+05:30</updated><id>http://localhost:4000/blog/2023/calcuate-pi-for-fun</id><content type="html" xml:base="http://localhost:4000/blog/2023/calcuate-pi-for-fun/"><![CDATA[<p>Hey there, fellow math and computer enthusiasts! Today, we’re diving into one of the most captivating and profound constants in mathematics - Pi (\(\pi\)). As enthusiasts of both math and computing, we understand the extraordinary significance of this simple, yet infinitely complex number. So, let’s embark on a journey to unravel the mysteries of pi and discover different ways of calculating \(\pi\).</p>

<p>You may have wondered how people compute the value of \(\pi\) accurately, and how do they know that they are accurate. Then you are at right place, today we will unravel the mysteries of convergence and error metrics.</p>

<figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/pi_for_fun/pi_comic.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

<blockquote>
"Truth is ever to be found in simplicity, and not in the multiplicity and confusion of things." – Isaac Newton
</blockquote>

<h3 id="introduction">Introduction</h3>
<p>Pi (\(\pi\)), a symbol revered by mathematicians and enthusiasts alike, encapsulates the profound link between the geometry of circles and the elegance of numbers. It’s no ordinary constant; it’s a mathematical enigma that carries the weight of countless equations and the beauty of infinite precision.</p>

<p>Defined as the ratio of a circle’s circumference to its diameter, pi unveils the mystery of circles in a single equation:</p>

\[\pi = \frac{Circumference}{Diameter}\]

<p>However, pi’s allure goes far beyond a simple fraction. Its decimal representation, an unending series of digits without repetition, makes it an irrational number. Let’s emphasize this infinite beauty with the well-known approximation:</p>

\[\pi \approx 3.14159\]

<p>Yet, pi’s significance reverberates throughout diverse mathematical and scientific domains. In geometry, pi enables us to calculate the areas and volumes of circles and spheres. In trigonometry, pi influences the sine and cosine functions, laying the foundation for understanding waves and oscillations. And when we venture into calculus, pi emerges yet again, intertwining with limits, integrals, and derivatives in intricate equations.</p>

<p>Beyond these equations, pi’s pervasive presence extends into the realms of physics, engineering, and beyond. From calculating the motion of planets to designing structures that stand the test of time, pi’s role is undeniable.</p>

<h3 id="origin-and-historical-significance-of-pi">Origin and Historical Significance of \(\pi\)</h3>
<p>Certainly, here’s a concise one-line summary of each historical point related to the origin and history of \(\pi\):</p>

<ol>
  <li>
    <p><strong>Ancient Egypt and Babylon (circa 1900–1600 BCE)</strong>: Early approximations of \(\pi\) as 3.125.</p>
  </li>
  <li>
    <p><strong>Ancient Greece (circa 250 BCE)</strong>: Archimedes’ geometric approach establishes bounds on \(\pi\) between 3.1408 and 3.1429.</p>
  </li>
  <li>
    <p><strong>India (circa 5th century CE)</strong>: Aryabhata approximates \(\pi\) as 62832/20000, or approximately 3.1416.</p>
  </li>
  <li>
    <p><strong>Islamic Golden Age (circa 9th-13th centuries CE)</strong>: Al-Khwarizmi and Al-Kashi contribute with polygonal approximations and precise calculations to 16 decimal places.</p>
  </li>
  <li>
    <p><strong>Europe (Medieval and Renaissance Periods)</strong>: Fibonacci and Ludolph van Ceulen make noteworthy contributions, with Ludolph calculating \(\pi\) to 35 decimal places.</p>
  </li>
</ol>

<h3 id="modern-methods-of-calculating-pi-python-implementation">Modern Methods of Calculating Pi: Python Implementation</h3>
<p>Let’s explore some modern methods used to calculate pi and provide Python implementations to demonstrate these techniques and calculating \(\pi\) upto 5000 digits.</p>

<h4 id="calculating-pi-using-machin-like-formula">Calculating \(\pi\) using Machin-like formula</h4>
<p>This equation was discovered in 1706 by John Machin, and has been in use for around 300 years. It is suitable for the calculation of Pi because it converges quickly. The formula relates pi to arctangent (inverse tangent) values. Here’s the formula:</p>

\[{\frac  {\pi }{4}}=4\arctan {\frac  {1}{5}}-\arctan {\frac  {1}{239}}\]

<p>The Taylor’s series expansion for arctangent is :</p>

\[arctan x=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{2n+1}}x^{2n+1}=x-{\frac {x^{3}}{3}}+{\frac {x^{5}}{5}}-{\frac {x^{7}}{7}}+\cdot\]

<h4 id="calculating-pi-using-wallis-product">Calculating \(\pi\) using Wallis Product</h4>

<h4 id="calculating-pi-using-monte-carlo-method">Calculating \(\pi\) using Monte Carlo Method</h4>

<h4 id="calculating-pi-using-viètes-formula">Calculating \(\pi\) using Viète’s formula</h4>]]></content><author><name></name></author><category term="math-for-fun" /><category term="python" /><category term="code" /><category term="math" /><summary type="html"><![CDATA[Fascinating ways of calculating $$\pi$$ upto 5000 digits.]]></summary></entry><entry><title type="html">Conway’s Game of Life</title><link href="http://localhost:4000/blog/2023/game-of-life/" rel="alternate" type="text/html" title="Conway’s Game of Life" /><published>2023-07-18T03:20:10+05:30</published><updated>2023-07-18T03:20:10+05:30</updated><id>http://localhost:4000/blog/2023/game-of-life</id><content type="html" xml:base="http://localhost:4000/blog/2023/game-of-life/"><![CDATA[<!--In the vast world of mathematical discoveries, there are certain creations that captivate our imagination and challenge our understanding of complexity.-->
<p>As a geeky teenager navigating the vast landscape of computer science and mathematics, it’s not uncommon to stumble upon mind-bending puzzles and intricate algorithms that pique our curiosity. One such fascinating discovery is Conway’s Game of Life, an intriguing cellular automaton that captivates the minds of young tech enthusiasts. Developed by the brilliant mathematician John Horton Conway, this simple yet powerful concept has become a playground for exploration and experimentation for many geeky teenagers.</p>

<figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/life/life2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

<blockquote>
"If experimenters have free will, then so do elementary particles." - John Horton Conway
</blockquote>
<h3 id="the-basics-of-conways-game-of-life">The Basics of Conway’s Game of Life</h3>

<p>Conway’s Game of Life is a zero-player game, meaning it requires no further input once the initial state is set. It consists of a grid of cells, each having two possible states: alive or dead. The rules that govern the evolution of these cells are deceptively simple but lead to complex and mesmerizing patterns.</p>

<h3 id="the-rules-of-life">The Rules of Life</h3>
<p>The Game of Life follows a set of simple rules that govern the behavior of its cellular automaton. These rules determine how each cell in the game’s grid evolves from one generation to the next. Here are the fundamental rules of the Game of Life:
Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent.</p>
<ol>
  <li>Any live cell with fewer than two live neighbors dies, as if by underpopulation.</li>
  <li>Any live cell with two or three live neighbors lives on to the next generation.</li>
  <li>Any live cell with more than three live neighbors dies, as if by overpopulation.</li>
  <li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ol>

<p>These four rules elegantly dictate the life and death of each cell, creating a dynamic system that unfolds over time.</p>

<p>By applying these rules simultaneously to every cell in the grid, the Game of Life progresses from one generation to the next, creating visually stunning and intricate patterns. Each cell’s state is updated based on the states of its neighboring cells, leading to a dynamic and evolving system.</p>

<blockquote>
"In Conway's Game of Life, chaos emerges from order."
</blockquote>

<h3 id="patterns-geeky-art-in-motion">Patterns: Geeky Art in Motion</h3>

<p>It’s time to geek out over the mind-boggling patterns that emerge within the Game of Life. I’ll use <a href="https://p5js.org/">p5.js</a> to implement this.</p>

<p>The algorithm for Conway’s Game of Life can be summarized in the following steps:</p>

<ul>
  <li>Create an initial grid: Set up a two-dimensional grid of cells, where each cell can be in one of two states: alive or dead. This initial configuration serves as the starting point for the game.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">make2DArray</span><span class="p">(</span><span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">rows</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">rows</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Iterate over the grid: For each cell in the grid, apply the rules to determine its state. To apply these rules, count the number of live neighbors for each cell. Neighbors include the eight cells adjacent to the current cell (horizontal, vertical, and diagonal). Based on the current state and the number of live neighbors, determine the cell’s state in the next generation.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">countNeighbours</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">alivenbrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">i</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">let</span> <span class="nx">rx</span> <span class="o">=</span> <span class="p">((</span><span class="nx">x</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nx">rows</span> <span class="o">+</span> <span class="nx">rows</span><span class="p">)</span><span class="o">%</span><span class="nx">rows</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">ry</span> <span class="o">=</span> <span class="p">((</span><span class="nx">y</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span><span class="o">%</span><span class="nx">cols</span> <span class="o">+</span> <span class="nx">cols</span><span class="p">)</span><span class="o">%</span><span class="nx">cols</span><span class="p">;</span>    
    
      <span class="k">if </span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">rx</span><span class="p">][</span><span class="nx">ry</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">){</span><span class="nx">alivenbrs</span> <span class="o">=</span> <span class="nx">alivenbrs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;}</span>

    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">alivenbrs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Update the grid: Once all cells have been evaluated and their next states determined, update the grid to reflect the new generation. Set each cell’s state according to the rules applied in the previous step.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">updateCell</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">liveNB</span> <span class="o">=</span>  <span class="nf">countNeighbours</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">curr_state</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">new_state</span> <span class="o">=</span> <span class="nx">curr_state</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">curr_state</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">liveNB</span> <span class="o">==</span> <span class="mi">3</span><span class="p">){</span>
    <span class="nx">new_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">curr_state</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">){</span>
    <span class="nx">new_state</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">curr_state</span><span class="o">&gt;=</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">liveNB</span><span class="o">&lt;</span><span class="mi">2</span> <span class="o">||</span> <span class="nx">liveNB</span> <span class="o">&gt;</span><span class="mi">3</span><span class="p">)){</span>
      <span class="nx">new_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">curr_state</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">){</span>
    <span class="nx">new_state</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">new_state</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Repeat: Iterate through the grid, applying the rules and updating the states of cells to create subsequent generations. Continue this process indefinitely or until a specific termination condition is met.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nf">gameOfLife</span><span class="p">(){</span>
  <span class="kd">let</span> <span class="nx">temp_curr</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">temp_prev</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">temp_0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">rows</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">temp_curr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">&lt;</span><span class="nx">cols</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">temp_curr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">updateCell</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>
      <span class="c1">//new_grid[i][j] = updateCell(i,j);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
      <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp_prev</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">temp_prev</span> <span class="o">=</span> <span class="nx">temp_curr</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
      <span class="nx">temp_0</span> <span class="o">=</span> <span class="nx">temp_curr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">grid</span><span class="p">[</span><span class="nx">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp_prev</span><span class="p">;</span>
  <span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp_0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<iframe src="https://editor.p5js.org/snaily16/full/yYPBNmpRk" style="width:100%;height:580px"></iframe>
<p>Please checkout the <a href="https://editor.p5js.org/snaily16/sketches/yYPBNmpRk">demo</a> and <a href="https://github.com/snaily16/GameOfLife">github code</a> here.</p>

<h4 id="glider-guns">Glider Guns</h4>

<p>Conway’s Game of Life also allows for the construction of various logical components. Glider guns, for example, are structures that continually generate gliders, which can be thought of as moving signals. These glider guns can be used to create logic gates such as AND, OR, and NOT gates, forming the building blocks of more complex computational systems within the game.</p>

<figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/life/life.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

<h3 id="complexity-and-universality-of-the-game">Complexity and Universality of the Game</h3>
<p>The Game of Life possesses both complexity and universality, making it a fascinating subject in the realm of computational theory. Let’s explore these concepts in more detail:</p>

<h4 id="the-emergence-of-complexity">The Emergence of Complexity</h4>

<p>Despite its simple set of rules, Conway’s Game of Life exhibits a stunning level of complexity. From the interplay of live and dead cells, intricate patterns emerge, ranging from stable structures to oscillators, gliders, and even self-replicating entities. The game’s evolution unfolds dynamically, showcasing the potential for endless possibilities within a finite set of rules.</p>

<h4 id="universality-turing-completeness">Universality: Turing Completeness</h4>

<p>One of the most astonishing aspects of Conway’s Game of Life is its universality, specifically its ability to simulate any Turing machine. A Turing machine is a theoretical model of computation that can solve any problem that can be computed algorithmically. By constructing specific configurations within the game, it is possible to create structures that mimic the behavior of a Turing machine, effectively transforming the Game of Life into a computational device capable of solving complex problems.</p>

<p>In summary, the Game of Life embodies both complexity and universality. Its simple rules give rise to intricate and visually stunning patterns, demonstrating the inherent complexity that can emerge from simplicity. Moreover, its ability to simulate any other computational system showcases its universality, illustrating the vast computational power that can be harnessed within this seemingly simple cellular automaton.</p>]]></content><author><name></name></author><category term="math-for-fun" /><category term="javascript" /><category term="game-of-life" /><category term="code" /><category term="math" /><summary type="html"><![CDATA[Conway's Game of Life implementation using p5.js]]></summary></entry><entry><title type="html">What, Why and Which?? Activation Functions</title><link href="http://localhost:4000/blog/2019/what-why-and-which-activation-functions/" rel="alternate" type="text/html" title="What, Why and Which?? Activation Functions" /><published>2019-04-15T01:11:05+05:30</published><updated>2019-04-15T01:11:05+05:30</updated><id>http://localhost:4000/blog/2019/what-why-and-which-activation-functions</id><content type="html" xml:base="http://localhost:4000/blog/2019/what-why-and-which-activation-functions/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Is deep learning useless if there is no large dataset available? NO!!!</title><link href="http://localhost:4000/blog/2018/is-deep-learning-useless-if-there-is-no-large-dataset-available-no/" rel="alternate" type="text/html" title="Is deep learning useless if there is no large dataset available? NO!!!" /><published>2018-12-05T00:32:40+05:30</published><updated>2018-12-05T00:32:40+05:30</updated><id>http://localhost:4000/blog/2018/is-deep-learning-useless-if-there-is-no-large-dataset-available-no</id><content type="html" xml:base="http://localhost:4000/blog/2018/is-deep-learning-useless-if-there-is-no-large-dataset-available-no/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Import Data into Google Colaboratory</title><link href="http://localhost:4000/blog/2018/import-data-into-google-colaboratory/" rel="alternate" type="text/html" title="Import Data into Google Colaboratory" /><published>2018-10-13T22:40:34+05:30</published><updated>2018-10-13T22:40:34+05:30</updated><id>http://localhost:4000/blog/2018/import-data-into-google-colaboratory</id><content type="html" xml:base="http://localhost:4000/blog/2018/import-data-into-google-colaboratory/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Harness the power of GPU and TPU</title><link href="http://localhost:4000/blog/2018/harness-the-power-of-gpu-and-tpu/" rel="alternate" type="text/html" title="Harness the power of GPU and TPU" /><published>2018-10-09T21:09:02+05:30</published><updated>2018-10-09T21:09:02+05:30</updated><id>http://localhost:4000/blog/2018/harness-the-power-of-gpu-and-tpu</id><content type="html" xml:base="http://localhost:4000/blog/2018/harness-the-power-of-gpu-and-tpu/"><![CDATA[]]></content><author><name></name></author></entry></feed>