<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>The Art of Concurrency | Snehal R. Gharat</title>
    <meta name="author" content="Snehal R. Gharat">
    <meta name="description" content="Unlock the power of concurrent programming in C, with practical examples using pthreads library">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="http://localhost:4000/blog/2024/pthreads-concurrency/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Snehal </span>R. Gharat</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">projects</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/">repositories</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">cv</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">The Art of Concurrency</h1>
    <p class="post-meta">August 30, 2024</p>
    <p class="post-tags">
      <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>
        ·  
        <a href="/blog/tag/c">
          <i class="fas fa-hashtag fa-sm"></i> c</a>  
          <a href="/blog/tag/code">
          <i class="fas fa-hashtag fa-sm"></i> code</a>  
          <a href="/blog/tag/os">
          <i class="fas fa-hashtag fa-sm"></i> os</a>  
          
        ·  
        <a href="/blog/category/code-for-fun">
          <i class="fas fa-tag fa-sm"></i> code-for-fun</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="markdown-content">
      <p>Hey there, fellow coders!</p>

<p>Are you ready to unravel the mystery of threads? Not the kind you use to sew or weave, but the kind that makes your computer run multiple tasks at same time. Yeah, that kind! No yarns, threads, or needles required!
In this post, we’ll dive into the world of pthreads in C, where we’ll learn how to create, manage, and synchronize threads to achieve concurrency and improve system performance. We’ll cover the basics of pthreads, exploring the best practices to follow and common pitfalls to avoid. So, buckle up and get ready to thread your way through the world of computer science!</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/threading/Cooking_multitasking.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

    </div>
</div>
<p>Imagine you’re cooking dinner and have to prepare multiple dishes at once. Cooking one dish after the other would take a lot of time; instead, you prepare each dish simultaneously. You’re chopping vegetables while the rice is cooking, and then preparing rotis while the vegetables are sautéing. This is an example of concurrency from day-to-day life.</p>

<blockquote>
"Nothing is particularly hard if you divide it into small jobs." – Henry Ford
</blockquote>
<p>In concurrency, multiple tasks are executed simultaneously, improving the overall efficiency and productivity of the system. In today’s world of multi-core processors and increasingly complex software systems, concurrency has become a crucial aspect of programming. By harnessing the power of concurrency, developers can create faster, more efficient, and more scalable applications that take full advantage of modern hardware. However, concurrent programming can be a daunting task, especially for those new to the field.</p>

<p>Let’s dive into the world of concurrent programming. One of the most popular ways to achieve concurrency in C programming is by using POSIX threads, also known as pthreads.</p>

<h2 id="what-are-pthread">What are pthread?</h2>
<p>POSIX threads, also known as pthreads, developed by IEEE, as a part of POSIX (Portable Operating System Interface) standard, are a set of APIs that allow developers to create multiple threads of execution within a single process. 
POSIX threads were developed in 1990s to provide a standardized threading API, addressing lack of portability and efficiency in concurrent code. While there were existing threading APIs, they were not compatible, making it difficult to write portable code. Pthreads aimed to provide a standardized API for multiple platforms.</p>

<p>The <code class="language-plaintext highlighter-rouge">pthreads.h</code> header file is the primary interface for POSIX threads. It provides a set of functions, macros, and types that enable developers to create, manage, and synchronize threads.</p>

<h2 id="thread-operations">Thread Operations</h2>
<p>In a POSIX threads environment, thread operations typically include -</p>

<ol>
  <li>Thread Creation: creating new threads within a process</li>
  <li>Termination: terminating threads when they’re no longer needed</li>
  <li>Synchronization: coordinating access to shared resources between threads</li>
  <li>Scheduling: managing the execution of threads by the OS</li>
  <li>Data management: managing shared data between threads</li>
  <li>Process interaction: interacting with the parent process and other threads</li>
</ol>

<p>The Pthread API contains around 100 functions. These functions can be grouped in four major groups:</p>

<ul>
  <li>Thread management functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_create(), pthread_join()</code>)</li>
  <li>Synchronization functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_mutex_lock(), pthread_cond_wait())</code>
</li>
  <li>Thread attribute functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_attr_init(), pthread_attr_setdetachstate())</code>
</li>
  <li>Thread-specific data functions <code class="language-plaintext highlighter-rouge">(e.g., pthread_setspecific(), pthread_getspecific())</code>
</li>
</ul>

<h2 id="thread-management">Thread Management</h2>
<p>When a program starts, it consists of a single, default thread, often referred to as the main thread. This thread is responsible for executing the main() function, which is the entry point of the program.
To get thread ID for the newly created thread, we use the <code class="language-plaintext highlighter-rouge">pthread_self</code> function.</p>

<h3 id="thread-creation-pthread_create">Thread Creation: pthread_create</h3>

<p>To create a new thread, we use the <code class="language-plaintext highlighter-rouge">pthread_create</code> function.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span> <span class="kr">thread</span><span class="p">,</span> 
                       <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span> <span class="n">attr</span><span class="p">,</span>
                       <span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> 
                       <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></div>
<p>Let’s break down each argument:</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">thread</code>: a pointer to a <code class="language-plaintext highlighter-rouge">pthread_t</code> variable that will store thread ID.</li>
  <li>
<code class="language-plaintext highlighter-rouge">attr</code>: a pointer to a <code class="language-plaintext highlighter-rouge">pthread_attr_t</code> structure that specifies thread attributes. (optional)</li>
  <li>
<code class="language-plaintext highlighter-rouge">start_routine</code>: a pointer to function that the new thread will execute.</li>
  <li>
<code class="language-plaintext highlighter-rouge">arg</code>: an argument to be passed to the <code class="language-plaintext highlighter-rouge">start_routine</code> function. It must be passed by reference as (void *) NULL</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">pthread_create</code> function returns zero on successful thread creation; otherwise, an error number shall be returned to indicate the error.</p>

<h4 id="best-practices-for-thread-creation">Best Practices for Thread Creation</h4>
<ol>
  <li>Use meaningful thread names to identify threads, this makes debugging easier.</li>
  <li>Use thread attributes to specify the thread’s scheduling policy, priority and other properties.</li>
  <li>Pass arguments carefully to avoid data corruption and ensure thread safety.</li>
</ol>

<h3 id="thread-termination-pthread_exit">Thread Termination: pthread_exit</h3>

<p>To terminate the calling thread, we use the <code class="language-plaintext highlighter-rouge">pthread_exit</code> function. It takes a single argument, <code class="language-plaintext highlighter-rouge">value_ptr</code>, which is a pointer to the exit status of the thread. This argument is optional, and if not provided, the thread exits with a default status.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value_ptr</span><span class="p">);</span>
</code></pre></div></div>
<p>This function allows thread to exit cleanly, realising any resources it may have allocated. While using the <code class="language-plaintext highlighter-rouge">pthread_exit</code>.</p>

<h4 id="best-practices-for-thread-termination">Best Practices for Thread Termination</h4>
<ol>
  <li>Use <code class="language-plaintext highlighter-rouge">pthread_exit</code> instead of <code class="language-plaintext highlighter-rouge">return</code> to terminate the thread. This ensures that the thread exists cleanly and releases resources it may have allocated.</li>
  <li>Pass on exit status to <code class="language-plaintext highlighter-rouge">pthread_exit</code> to provide information about the thread termination.</li>
  <li>Avoid calling <code class="language-plaintext highlighter-rouge">pthread_exit</code> from signal handler to prevent unexpected behaviour.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">pthread_join</code> to wait for the thread to terminate and ensure that resources are released.</li>
</ol>

<h3 id="waiting-for-thread-termination-pthread_join">Waiting for Thread Termination: pthread_join</h3>
<p>In addition to creating threads, it’s essential to manage their termination properly. One of the most critical aspects of thread termination is waiting for a thread to finish its execution. This is where <code class="language-plaintext highlighter-rouge">pthread_join</code> comes into play. When <code class="language-plaintext highlighter-rouge">pthread_join</code> is called the main program will block until the specified thread terminates.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">value_ptr</span><span class="p">);</span>
</code></pre></div></div>

<p>Let’s break down each argument:</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">thread</code>: a pointer to a <code class="language-plaintext highlighter-rouge">pthread_t</code> variable that will store thread ID.</li>
  <li>
<code class="language-plaintext highlighter-rouge">value_ptr</code>: a pointer to a location where the thread’s return value will be stored.</li>
</ul>

<p>Once the thread finishes the execution, <code class="language-plaintext highlighter-rouge">pthread_join</code> will return the thread’s return value through the <code class="language-plaintext highlighter-rouge">value_ptr</code> argument. It allows you to synchornize the main program with the thread’s execution. This is particularly useful when the main program needs to wait for a thread to complete a task before proceeding.
If a thread encounters an error, <code class="language-plaintext highlighter-rouge">pthread_join</code> can help you catch and handle the error properly.</p>

<h4 id="best-practices-for-using-pthread_join">Best Practices for Using pthread_join</h4>
<ol>
  <li>Make it a habit to join threads to ensure proper resource cleanup and synchronization</li>
  <li>Always pair <code class="language-plaintext highlighter-rouge">pthread_join</code> with <code class="language-plaintext highlighter-rouge">pthread_create</code> to ensure that threads are properly created and terminated.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">pthread_join</code> to catch and handle errors that may occur during thread execution.</li>
</ol>

<p>Here is an example code that demonstrates the best practices:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"Hello, Thread!!!"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iret</span><span class="p">;</span>

    <span class="c1">// Create a thread</span>
    <span class="n">iret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_func</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error - pthread_create() return code: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">iret</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pthread_create for thread returns: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">iret</span><span class="p">);</span>
    
    <span class="c1">// Wait for the thread to finish</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Thread finished with return value %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">retval</span><span class="p">);</span>
    
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="c1">// Get the argument passed to the thread</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

    <span class="c1">// Get the thread ID</span>
    <span class="n">pthread_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Thread %ld started with message: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tid</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    
    <span class="c1">// Return a value to indicate success</span>
    <span class="n">pthread_exit</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To compile this program using GCC, we need to use the <code class="language-plaintext highlighter-rouge">-pthread</code> flag. This flag tells the compiler to link against the Pthread library. If you’re using a different C compiler, you’ll need to use a different (but equivalent) flag to link against the Pthread library. For example, with Clang compiler, we use the <code class="language-plaintext highlighter-rouge">-lpthread</code> flag.</p>

<p>Below is the example of how we can compile the above code (let’s name it thread_basic.c) in GCC:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -o thread_basic thread_basic.c -pthread
</code></pre></div></div>

<h2 id="thread-synchronization">Thread Synchronization</h2>

<p>When working with pthreads, synchronization is key to ensuring that your threads play nicely together. It is curcial to ensure that threads access shared resources safely and efficiently. Pthreads provide a range of synchronization functions that allow threads to coordinate their actions and avoid race conditions.</p>

<p>Types of Synchronization Functions:</p>
<ol>
  <li>Mutexes (Mutual Exclusion): Allow only one thread to access a shared resource at a time.</li>
  <li>Condition Variables: Allow threads to wait for a specific condition to occur before proceeding.</li>
  <li>Semaphores: Allow a limited number of threads to access a shared resource.</li>
  <li>Barriers: Allow multiple threads to wait until all threads have reached a specific point.</li>
</ol>

<p>To illustrate the concept of synchronization functions, let’s consider the earlier example of cooking dinner, but lets add multiple chefs.</p>

<h3 id="problem-statement-the-dinner-party-story">Problem Statement: The Dinner Party Story</h3>

<p>Imagine a busy kitchen where multiple chefs (threads) are working together to prepare a multi-course dinner for a large party. The kitchen has limited resources, such as ovens, stoves and utensils, which need to be shared safely among the chefs.</p>

<h3 id="example-1-critical-section-problem-with-mutexes">Example 1: Critical Section Problem with Mutexes</h3>

<p>Two chefs Alex and Luke, need to access the oven to bake different dishes. Without synchronization, both chefs might try to access the oven simultaneously, leading to conflicts and potentially ruining the dishes. To avoid this problem, the chefs use a mutex lock to synchronize the access to the oven.</p>

<p>A mutex (short for “mutual exclusion”) is a synchronization primitive that allows only one thread to access a shared resource at a time. In this example we’ll use the <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code> function to lock the mutex, ensuring that only one chef can access the oven at a time.</p>

<h4 id="declaration">Declaration:</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code> locks the mutex specified by varibale “mutex”. If the mutex is already locked, the calling thread will block until the mutex is unlocked by <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code>. 
The <code class="language-plaintext highlighter-rouge">pthread_mutex_trylock</code> is similar to <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code>, except that if the mutex object referenced by mutex is currently locked, instead of blocking the thread, it return immediately.</p>

<p>The <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code> and <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code> will returns 0 on success and error code on failure. The <code class="language-plaintext highlighter-rouge">pthread_mutex_trylock</code> will return 0 if a lock on the mutex object referenced by mutex is acquired, otherwise, and error code.</p>

<h4 id="the-code">The Code:</h4>
<p>Here is the code snippet that demonstrates how the chefs use a mutex lock to synchronize their actions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">oven_mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">Chef1</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="c1">// Bake dish 1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef 1 is baking a cake... </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">Chef2</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="c1">// Bake dish 2</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef 2 is baking a pizza... </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oven_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="how-it-works">How it Works:</h4>
<ul>
  <li>The mutex <code class="language-plaintext highlighter-rouge">oven_mutex</code> is shared by Chef1 and Chef2 and is initialized using <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code>.</li>
  <li>They create their threads and start executing their respective thread functions. When Chef1 tries to access the oven, it locks the mutex using <code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code>.</li>
  <li>Once the mutexis locked, Chef1 enters the critical section and bakes the cake.</li>
  <li>Meanwhile, if Chef2 also access the oven and see the mutex in locked state, it will block until the mutex is unlocked by Chef1.</li>
  <li>After baking the cake, Chef1 unlocks the mutex using <code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code>.</li>
  <li>And similarly, chef2 locks the mutex, bakes the pizza and unlocks the mutex.</li>
</ul>

<p>By using a mutex lock, the chefs ensure that only one of them can access the oven at a time, preventing conflictst and ensuring that each dish is prepared perfectly.</p>

<h3 id="example-2-producer-consumer-problem-with-condition-variables">Example 2: Producer-Consumer Problem with Condition Variables</h3>

<p>Now, one of your chef, let’s say Claire, is responsible for preparing ingredients, while another chef, Phil, needs to use those ingredients to prepare a dish. 
Without synchronization, Phil (consumer) might try to use the ingredients before Claire (producer) has finished preparing them, reuslting in a dish that is incomplete or incorrect. For instance, Claire might be preparing a sauce, while Phil tries to use it before it’s ready, leading to a culinary disaster.</p>

<p>To avoid this problem, the chefs use a condition variable to synchronize their actions. A condition variable is a synchronization primitive that allows threads to wait until a specific condition is met. In this example we’ll use the <code class="language-plaintext highlighter-rouge">pthread_cond_wait</code> and <code class="language-plaintext highlighter-rouge">pthread_cond_signal</code> functions to implement the producer-consumer synchronization.</p>

<h4 id="declaration-1">Declaration:</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// wait on a condition</span>
<span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_timedwait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> 
                           <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">abstime</span><span class="p">);</span>

<span class="c1">// signal or broadcast a condition</span>
<span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>Wait on a condition:
    <ul>
      <li>Releases the mutex specified by <code class="language-plaintext highlighter-rouge">mutex</code> and waits until the condition varibale <code class="language-plaintext highlighter-rouge">cond</code> is signaled.</li>
      <li>They are called with mutex locked by the calling thread.</li>
      <li>Returns 0 on success, or an error code on failure</li>
      <li>The <code class="language-plaintext highlighter-rouge">pthread_cond_timedwait()</code> function is the same as <code class="language-plaintext highlighter-rouge">pthread_cond_wait()</code> except that an error is returned if the absolute time specified by abstime passes before the condition cond is signaled or broadcasted, or if the absolute time specified by abstime has already been passed at the time of the call.</li>
    </ul>
  </li>
  <li>Signal or brodcast a condition:
    <ul>
      <li>Signals the condition variable <code class="language-plaintext highlighter-rouge">cond</code>, waking up one or more threads that are waiting on it.</li>
      <li>Returns 0 on success, or an error code on failure</li>
      <li>The <code class="language-plaintext highlighter-rouge">pthread_cond_signal</code> wakes up at least one of the thread that are waiting on <code class="language-plaintext highlighter-rouge">cond</code>, whereas the <code class="language-plaintext highlighter-rouge">pthread_cond_broadcast</code> wakes up all the threads that are waiting.</li>
      <li>There is no effect for these functions if there are no threads currently blocked on <code class="language-plaintext highlighter-rouge">cond</code>.</li>
    </ul>
  </li>
</ol>

<h4 id="the-code-1">The Code:</h4>
<p>Here is the code snippet that demonstrates how the chefs use a condition variable to synchronize their actions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">sauce_mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">sauce_cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sauce_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Producer: Claire</span>
<span class="kt">void</span> <span class="nf">Chef_Producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="c1">// Prepare the sauce</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef Claire is preparing the sauce...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">sauce_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_cond</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Consumer: Phil</span>
<span class="kt">void</span> <span class="nf">Chef_Consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sauce_ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Use the sauce to prepare the dish</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef Phil is preparing the dish...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">sauce_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sauce_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="how-it-works-1">How it Works:</h4>
<ul>
  <li>The mutex <code class="language-plaintext highlighter-rouge">sauce_mutex</code> and condition varibale <code class="language-plaintext highlighter-rouge">sauce_cond</code> are initialized using <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> and <code class="language-plaintext highlighter-rouge">PTHREAD_COND_INITIALIZER</code>, respectively.</li>
  <li>Claire (the producer) creates its thread and starts executing its thread function, she prepares the sauce and sets the <code class="language-plaintext highlighter-rouge">sauce_ready</code> flag to 1.</li>
  <li>Claire signals the condition variable using <code class="language-plaintext highlighter-rouge">pthread_cond_signal</code>, waking up Phil (the consumer).- Phil waits on the condition variable using <code class="language-plaintext highlighter-rouge">pthread_cond_wait</code> until the sauce is ready. Once its ready, Phil uses it to prepare the dish.</li>
  <li>Phil resets the <code class="language-plaintext highlighter-rouge">sauce_ready</code> flag to 0 to indicate that the sauce is no longer available.</li>
</ul>

<p>By using a condition variable, both Claire and Phil ensures that Phil wait until Claire has finished preparing the sauce, ensuring the dish is prepared correctly.</p>

<h3 id="example-3-reader-writer-problem-with-semaphores">Example 3: Reader-Writer Problem with Semaphores</h3>

<p>Our head chef, Gloria, has meticulously recorded all her grandmother’s recipes in her treasured recipe book, which only she is allowed to modify. Her team of chefs, including Phil, Claire, Alex and Luke, need to access to prepare different dishes.</p>

<p>Without proper synchronization, multiple chefs might attempt to access the recipe book simultaneously, leading to inconsistencies and errors. For instance, if one chef is reading a recipe while another chef is updating it, the first chef might obtain an outdated or incorrect recipe. To avoid this problem, the chefs utilize a semaphore to synchronize their access to the recipe book. A semaphore is a synchronization primitive that allows a limited number of threads to access a shared resource.</p>

<h4 id="declaration-2">Declaration</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// lock a semaphore</span>
<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="c1">// unlock a semaphore</span>
<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>Lock a semaphore:
    <ul>
      <li>Decrements the semaphore value.</li>
      <li>If the semaphore value is currently zero, <code class="language-plaintext highlighter-rouge">sem_wait</code> blocks the calling thread until the semaphore value becomes positive. When semaphore value is positive, it decrements the value and allows the thread to proceed.</li>
      <li>Unlike <code class="language-plaintext highlighter-rouge">sem_wait</code>, <code class="language-plaintext highlighter-rouge">sem_trywait</code> does not block the calling thread if the semaphore value is zero. Instead, it returns an error code.</li>
      <li>Returns 0 on success, or an error code on failure.</li>
    </ul>
  </li>
  <li>Unlock a semaphore:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">sem_post</code> call, increments the semaphore value and wakes up one or more threads that are waiting on it.</li>
      <li>Returns 0 on success, or an error code on failure.</li>
    </ul>
  </li>
</ol>

<h4 id="the-code-2">The Code:</h4>

<p>Here’s an example code snipped that demonstrates how the chefs use a semaphore to synchronize their access to the recipe book:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">sem_t</span> <span class="n">recipe_book_semaphore</span><span class="p">;</span>
<span class="cp">#define READERS 5
</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">ChefReader</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="c1">// Read the recipe book</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Chef %ld is reading recipe book...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">HeadChef</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
    <span class="c1">// Wait for all readers to finish</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">READERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="c1">// Update the recipe book</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Head Chef is updating recipe book...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">READERS</span><span class="p">);</span> <span class="c1">// Allow up to n readers to access simultaneously</span>
  <span class="c1">// Create threads here...</span>
  <span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recipe_book_semaphore</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="how-it-works-2">How it Works:</h4>
<ul>
  <li>The semaphore <code class="language-plaintext highlighter-rouge">recipe_book_semaphore</code> is initialized uisng the <code class="language-plaintext highlighter-rouge">sem_t</code> type. This semaphore is used to synchronize access to the recipe book.</li>
  <li>When a ChefReader thread arrives, it waits for the semaphore to be available using sem_wait. If the semaphore is available, the thread decrements its value and continues execution. Since multiple ChefReader threads can decrement the semaphore value simultaneously, multiple readers can access the recipe book at the same time.</li>
  <li>When a HeadChef thread arrives, it also waits for the semaphore to be available using sem_wait. However, since the semaphore value is decremented by the ChefReader threads, the HeadChef thread will block until all ChefReader threads have finished reading the recipe book and released the semaphore. This ensures that the HeadChef thread has exclusive access to the recipe book when updating it.</li>
  <li>When a ChefReader thread finishes reading the recipe book, it releases the semaphore using sem_post, incrementing its value. This allows other ChefReader threads to access the recipe book.</li>
  <li>When the HeadChef thread finishes updating the recipe book, it releases the semaphore using sem_post, incrementing its value. This allows other threads to access the recipe book.</li>
</ul>

<p>By using a semaphore to synchronize access to the recipe book, the code ensures that multiple ChefReader threads can read the recipe book simultaneously, while the HeadChef thread has exclusive access to the recipe book when updating it.</p>


    </div>
  </article>


  
    
    <br>
    <hr>
    <br>
    <ul class="list-disc pl-8"></ul>

    <!-- Adds related posts to the end of an article -->
    <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2>
    <p class="mb-2">Here are some more articles you might like to read next:</p>
  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2018/harness-the-power-of-gpu-and-tpu/">Harness the power of GPU and TPU</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2018/import-data-into-google-colaboratory/">Import Data into Google Colaboratory</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2018/is-deep-learning-useless-if-there-is-no-large-dataset-available-no/">Is deep learning useless if there is no large dataset available? NO!!!</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2019/what-why-and-which-activation-functions/">What, Why and Which?? Activation Functions</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/calcuate-pi-for-fun/">Beyond 3.14</a>
  </li>

</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2024 Snehal R. Gharat. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
